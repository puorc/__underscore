<!DOCTYPE html>

<html>
<head>
  <title>collections.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="array.html">
                  array.js
                </a>
              
                
                <a class="source" href="collections.html">
                  collections.js
                </a>
              
                
                <a class="source" href="functions.html">
                  functions.js
                </a>
              
                
                <a class="source" href="objects.html">
                  objects.js
                </a>
              
                
                <a class="source" href="utility.html">
                  utility.js
                </a>
              
            </div>
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>collections.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> utility = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./utility.js"</span>);
<span class="hljs-keyword">const</span> TYPE = {
    <span class="hljs-attr">array_like</span>: <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"array_like"</span>),
    <span class="hljs-attr">object</span>: <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"object"</span>),
    <span class="hljs-attr">others</span>: <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"others"</span>)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">determineType</span>(<span class="hljs-params">list</span>) </span>{
    <span class="hljs-keyword">if</span> (list.length !== <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">return</span> TYPE.array_like;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> list === <span class="hljs-string">"object"</span>) {
        <span class="hljs-keyword">return</span> TYPE.object;
    } <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> TYPE.others;
}

<span class="hljs-comment">/**
 * Iterates over a list of elements, yielding each in turn to an iteratee function. The iteratee is bound to the context object, if one is passed.
 * Each invocation of iteratee is called with three arguments: (element, index, list). If list is a JavaScript object, iteratee's arguments will be (value, key, list). 
 * Returns the list for chaining.
 * @param {*} list 
 * @param {*} iteratee 
 * @param {*} context 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">each</span>(<span class="hljs-params">list, iteratee, context</span>) </span>{
    <span class="hljs-keyword">var</span> bindedIteratee = iteratee;
    <span class="hljs-keyword">if</span> (context !== <span class="hljs-literal">undefined</span>) {
        bindedIteratee = iteratee.bind(context);
    }
    <span class="hljs-keyword">switch</span> (determineType(list)) {
        <span class="hljs-keyword">case</span> TYPE.array_like:
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) {
                bindedIteratee(list[i], i, list);
            }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> TYPE.object:
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> list) {
                bindedIteratee(list[key], key, list);
            }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> TYPE.others:
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span>;
    }
}

<span class="hljs-comment">/**
 * Produces a new array of values by mapping each value in list through a transformation function (iteratee). 
 * The iteratee is passed three arguments: the value, then the index (or key) of the iteration, and finally a reference to the entire list.
 * @param {*} list 
 * @param {*} iteratee 
 * @param {*} context 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">list, iteratee, context</span>) </span>{
    <span class="hljs-keyword">var</span> bindedIteratee = iteratee,
        returnArray = [];
    <span class="hljs-keyword">if</span> (context !== <span class="hljs-literal">undefined</span>) {
        bindedIteratee = iteratee.bind(context);
    }
    <span class="hljs-keyword">switch</span> (determineType(list)) {
        <span class="hljs-keyword">case</span> TYPE.array_like:
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) {
                returnArray.push(bindedIteratee(list[i], i, list));
            }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> TYPE.object:
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> list) {
                returnArray.push(bindedIteratee(list[key], key, list));
            }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> TYPE.others:
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">return</span> returnArray;
}

<span class="hljs-comment">/**
 * Also known as inject and foldl, reduce boils down a list of values into a single value. 
 * Memo is the initial state of the reduction, and each successive step of it should be returned by iteratee. 
 * The iteratee is passed four arguments: the memo, then the value and index (or key) of the iteration, and finally a reference to the entire list.
 * If no memo is passed to the initial invocation of reduce, the iteratee is not invoked on the first element of the list. 
 * The first element is instead passed as the memo in the invocation of the iteratee on the next element in the list.
 * @param {*} list 
 * @param {*} iteratee 
 * @param {*} memo 
 * @param {*} context 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduce</span>(<span class="hljs-params">list, iteratee, memo, context</span>) </span>{
    <span class="hljs-keyword">var</span> bindedIteratee = iteratee,
        result, theMemo = memo;
    <span class="hljs-keyword">if</span> (context !== <span class="hljs-literal">undefined</span>) {
        bindedIteratee = iteratee.bind(context);
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) {
        <span class="hljs-keyword">if</span> (theMemo !== <span class="hljs-literal">undefined</span>) {

        }
    }
}

<span class="hljs-comment">/**
 * Looks through each value in the list, returning an array of all the values that pass a truth test (predicate).
 * @param {*} list 
 * @param {*} predicate 
 * @param {*} context 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span>(<span class="hljs-params">list, predicate, context</span>) </span>{
    <span class="hljs-keyword">var</span> bindedIteratee = predicate,
        result = [];
    <span class="hljs-keyword">if</span> (context !== <span class="hljs-literal">undefined</span>) {
        bindedIteratee = predicate.bind(context);
    }
    <span class="hljs-keyword">switch</span> (determineType(list)) {
        <span class="hljs-keyword">case</span> TYPE.array_like:
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) {
                <span class="hljs-keyword">if</span> (predicate(list[i])) {
                    result.push(list[i]);
                }
            }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> TYPE.object:
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> list) {
                <span class="hljs-keyword">if</span> (predicate(list[key])) {
                    result.push(list[key]);
                }
            }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> TYPE.others:
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Returns true if all of the values in the list pass the predicate truth test.
 *  Short-circuits and stops traversing the list if a false element is found.
 * @param {*} list 
 * @param {*} predicate 
 * @param {*} context 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">every</span>(<span class="hljs-params">list, predicate, context</span>) </span>{
    <span class="hljs-keyword">var</span> bindedIteratee = predicate;
    <span class="hljs-keyword">if</span> (context !== <span class="hljs-literal">undefined</span>) {
        bindedIteratee = predicate.bind(context);
    }
    <span class="hljs-keyword">switch</span> (determineType(list)) {
        <span class="hljs-keyword">case</span> TYPE.array_like:
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) {
                <span class="hljs-keyword">if</span> (!predicate(list[i]))
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> TYPE.object:
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> list) {
                <span class="hljs-keyword">if</span> (!predicate(list[key])) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> TYPE.others:
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-comment">/**
 * Returns true if any of the values in the list pass the predicate truth test. 
 * Short-circuits and stops traversing the list if a true element is found.
 * @param {*} list 
 * @param {*} predicate 
 * @param {*} context 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">some</span>(<span class="hljs-params">list, predicate, context</span>) </span>{
    <span class="hljs-keyword">var</span> bindedIteratee = predicate;
    <span class="hljs-keyword">if</span> (context !== <span class="hljs-literal">undefined</span>) {
        bindedIteratee = predicate.bind(context);
    }
    <span class="hljs-keyword">if</span> (predicate === <span class="hljs-literal">undefined</span>) {
        predicate = <span class="hljs-built_in">Boolean</span>;
    }
    <span class="hljs-keyword">switch</span> (determineType(list)) {
        <span class="hljs-keyword">case</span> TYPE.array_like:
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) {
                <span class="hljs-keyword">if</span> (predicate(list[i]))
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> TYPE.object:
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> list) {
                <span class="hljs-keyword">if</span> (predicate(list[key])) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
            }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> TYPE.others:
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-comment">/**
 * A convenient version of what is perhaps the most common use-case for map: extracting a list of property values.
 * @param {*} list 
 * @param {*} propertyName 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pluck</span>(<span class="hljs-params">list, propertyName</span>) </span>{
    <span class="hljs-keyword">return</span> map(list, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
        <span class="hljs-keyword">if</span> (propertyName <span class="hljs-keyword">in</span> item) {
            <span class="hljs-keyword">return</span> item[propertyName];
        }
    });
}
<span class="hljs-comment">/**
 * Returns the maximum value in list. If an iteratee function is provided, 
 * it will be used on each value to generate the criterion by which the value is ranked.
 * @param {*} list 
 * @param {*} iteratee 
 * @param {*} context 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">max</span>(<span class="hljs-params">list, iteratee, context</span>) </span>{
    <span class="hljs-keyword">var</span> bindedIteratee = iteratee,
        max, maxObj;
    <span class="hljs-keyword">if</span> (context !== <span class="hljs-literal">undefined</span>) {
        bindedIteratee = iteratee.bind(context);
    }
    <span class="hljs-keyword">switch</span> (determineType(list)) {
        <span class="hljs-keyword">case</span> TYPE.array_like:
            <span class="hljs-keyword">let</span> isFirstTime = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) {
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> bindedIteratee(list[i], i, list) === <span class="hljs-string">"number"</span>) {
                    <span class="hljs-keyword">if</span> (isFirstTime) {
                        max = bindedIteratee(list[i], i, list);
                        maxObj = list[i];
                        isFirstTime = <span class="hljs-literal">false</span>;
                    }
                    <span class="hljs-keyword">if</span> (bindedIteratee(list[i], i, list) &gt; max) {
                        max = bindedIteratee(list[i], i, list);
                        maxObj = list[i];
                    }
                }
            }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">return</span> maxObj;
}

<span class="hljs-comment">/**
 * Produce a random sample from the list. Pass a number to return n random elements from the list. 
 * Otherwise a single random item will be returned.
 * @param {*} list 
 * @param {*} n 
 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>has been tested manually</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sample</span>(<span class="hljs-params">list, n</span>) </span>{
    <span class="hljs-keyword">if</span> (determineType(list) === TYPE.array_like) {
        <span class="hljs-keyword">if</span> (n === <span class="hljs-literal">undefined</span>) {
            <span class="hljs-keyword">return</span> list[utility.random(list.length - <span class="hljs-number">1</span>)];
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">let</span> result = [];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
                result.push(utility.random(list.length - <span class="hljs-number">1</span>));
            }
            <span class="hljs-keyword">return</span> result;
        }
    }
}

<span class="hljs-comment">/**
 * Creates a real Array from the list (anything that can be iterated over). 
 * Useful for transmuting the arguments object.
 * @param {*} list 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toArray</span>(<span class="hljs-params">list</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.slice.call(list);
}

<span class="hljs-comment">/**
 * Return the number of values in the list.
 * @param {*} list 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">size</span>(<span class="hljs-params">list</span>) </span>{
    <span class="hljs-keyword">switch</span> (determineType(list)) {
        <span class="hljs-keyword">case</span> TYPE.array_like:
            <span class="hljs-keyword">return</span> list.length;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> TYPE.object:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(list).length;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>;
    }
}

<span class="hljs-comment">/**
 * Split array into two arrays: one whose elements all satisfy predicate and one whose elements all do not satisfy predicate.
 * @param {*} array 
 * @param {*} predicate 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partition</span>(<span class="hljs-params">array, predicate</span>) </span>{
    <span class="hljs-keyword">if</span> (!array <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> rightResult = [],
    otherResult = [],
    result = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) {
        predicate(array[i]) ? rightResult.push(array[i]) : otherResult.push(array[i]);
    }
    result.push(rightResult);
    result.push(otherResult);
    <span class="hljs-keyword">return</span> result;
}
<span class="hljs-built_in">module</span>.exports = {
    each,
    map,
    filter,
    every,
    some,
    pluck,
    max,
    sample,
    toArray,
    size,
    partition
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
