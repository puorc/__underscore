<!DOCTYPE html>

<html>
<head>
  <title>array.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="array.html">
                  array.js
                </a>
              
                
                <a class="source" href="collections.html">
                  collections.js
                </a>
              
                
                <a class="source" href="functions.html">
                  functions.js
                </a>
              
                
                <a class="source" href="objects.html">
                  objects.js
                </a>
              
                
                <a class="source" href="utility.html">
                  utility.js
                </a>
              
            </div>
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>array.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAvailable</span>(<span class="hljs-params">array</span>) </span>{
    <span class="hljs-keyword">return</span> array.length !== <span class="hljs-literal">undefined</span> &amp;&amp; array.length !== <span class="hljs-literal">null</span>;
}

<span class="hljs-comment">/**
 * Returns the first element of an array. Passing n will return the first n elements of the array.
 * @param {*} array 
 * @param {*} n 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">first</span>(<span class="hljs-params">array, n = <span class="hljs-number">1</span></span>) </span>{
    <span class="hljs-keyword">if</span> (isAvailable(array))
        <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span> array[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.slice.call(array, <span class="hljs-number">0</span>, n);
}

<span class="hljs-comment">/**
 * Returns everything but the last entry of the array. Especially useful on the arguments object. Pass n to exclude the last n elements from the result.
 * @param {*} array 
 * @param {*} n 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initial</span>(<span class="hljs-params">array, n = <span class="hljs-number">1</span></span>) </span>{
    <span class="hljs-keyword">if</span> (isAvailable(array))
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.slice.call(array, <span class="hljs-number">0</span>, array.length - n);
}

<span class="hljs-comment">/**
 * Returns the last element of an array. Passing n will return the last n elements of the array.
 * @param {*} array 
 * @param {*} n 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">last</span>(<span class="hljs-params">array, n = <span class="hljs-number">1</span></span>) </span>{
    <span class="hljs-keyword">if</span> (isAvailable(array))
        <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span> array[array.length - <span class="hljs-number">1</span>];
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.slice.call(array, array.length - n);
}

<span class="hljs-comment">/**
 * Returns the rest of the elements in an array. Pass an index to return the values of the array from that index onward.
 * @param {*} array 
 * @param {*} index 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rest</span>(<span class="hljs-params">array, index = <span class="hljs-number">1</span></span>) </span>{
    <span class="hljs-keyword">if</span> (isAvailable(array))
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.slice.call(array, index);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compact</span>(<span class="hljs-params">array</span>) </span>{
    <span class="hljs-keyword">if</span> (isAvailable(array)) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.filter.call(array, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Boolean</span>(element);
        });
    }
}
<span class="hljs-comment">/**
 * Flattens a nested array (the nesting can be to any depth). If you pass shallow, the array will only be flattened a single level.
 * @param {*} array 
 * @param {*} shallow 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">array</span>) </span>{
    <span class="hljs-keyword">if</span> (isAvailable(array)) {
        <span class="hljs-keyword">if</span> (!flatten.storeArray)
            flatten.storeArray = [];
        <span class="hljs-built_in">Array</span>.prototype.forEach.call(array, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(item))
                flatten(item);
            <span class="hljs-keyword">else</span>
                flatten.storeArray.push(item);
        });
        <span class="hljs-keyword">return</span> flatten.storeArray;
    }
}

<span class="hljs-comment">/**
 * Returns a copy of the array with all instances of the values removed.
 * @param {*} array 
 * @param {*} values 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">without</span>(<span class="hljs-params">array, ...values</span>) </span>{
    <span class="hljs-keyword">if</span> (isAvailable(array)) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.filter.call(array, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{
            <span class="hljs-keyword">return</span> !values.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">items</span>) </span>{
                <span class="hljs-keyword">return</span> items === item;
            });
        });
    }
}
<span class="hljs-comment">/**
 * Computes the union of the passed-in arrays: the list of unique items, in order, that are present in one or more of the arrays. 
 * @param {*} arrays 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">union</span>(<span class="hljs-params">...arrays</span>) </span>{
    <span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arrays.length; i++) {
        arrays[i].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{
            s.add(item);
        });
    }
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(s);
}
<span class="hljs-comment">/**
 * Computes the list of values that are the intersection of all the arrays. Each value in the result is present in each of the arrays.
 * @param {*} arrays 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intersection</span>(<span class="hljs-params">...arrays</span>) </span>{
    <span class="hljs-keyword">var</span> storeArray = [],
        result = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>to avoid cases like [1, 2, 2] to be misjudged</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (arrays.length === <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> arrays[<span class="hljs-number">0</span>];

    storeArray = storeArray.concat(...arrays).sort();
    <span class="hljs-keyword">var</span> tmp = storeArray[<span class="hljs-number">0</span>],
        count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; storeArray.length; i++) {
        <span class="hljs-keyword">if</span> (tmp === storeArray[i])
            count++;
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (count &gt;= arrays.length)
                result.push(tmp);
            tmp = storeArray[i];
            count = <span class="hljs-number">1</span>;
        }
    }
    <span class="hljs-keyword">if</span> (count &gt;= arrays.length)
        result.push(tmp);
    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Similar to without, but returns the values from array that are not present in the other arrays.
 * @param {*} array 
 * @param {*} others 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">difference</span>(<span class="hljs-params">array, others = []</span>) </span>{
    <span class="hljs-keyword">return</span> without(array, ...others);
}

<span class="hljs-comment">/**
 * Remain to be done, need some algorithms background to accomplish.
 * uniq_.uniq(array, [isSorted], [iteratee]) Alias: unique 
 * Produces a duplicate-free version of the array, using === to test object equality.
 * In particular only the first occurence of each value is kept. If you know in advance that the array is sorted, 
 * passing true for isSorted will run a much faster algorithm. If you want to compute unique items based on a transformation, 
 * pass an iteratee function.
 */</span>


<span class="hljs-comment">/**
 * Merges together the values of each of the arrays with the values at the corresponding position. 
 * Useful when you have separate data sources that are coordinated through matching array indexes.
 * @param {*} arrays 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">zip</span>(<span class="hljs-params">...arrays</span>) </span>{
    <span class="hljs-keyword">var</span> result = [];
    <span class="hljs-keyword">if</span> (arrays.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (arrays.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arrays[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">if</span> (!arrays.every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{
            <span class="hljs-keyword">return</span> item.length === arrays[<span class="hljs-number">0</span>].length;
        })) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arrays[<span class="hljs-number">0</span>].length; i++) {
            <span class="hljs-keyword">let</span> tmpArray = [];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arrays.length; j++) {
                tmpArray.push(arrays[j][i]);
            }
            result.push(tmpArray);
        }
    }
    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * The opposite of zip. Given an array of arrays, returns a series of new arrays, 
 * the first of which contains all of the first elements in the input arrays, the second of which contains all of the second elements, and so on.
 * @param {*} array 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unzip</span>(<span class="hljs-params">arrays</span>) </span>{
    <span class="hljs-keyword">return</span> zip(...arrays);
}
<span class="hljs-comment">/**
 * Converts arrays into objects. 
 * Pass either a single list of [key, value] pairs, or a list of keys, and a list of values. If duplicate keys exist, the last value wins.
 * @param {*} list 
 * @param {*} values 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(<span class="hljs-params">list, values</span>) </span>{
    <span class="hljs-keyword">var</span> returnObject = {};
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(list) &amp;&amp; <span class="hljs-built_in">Array</span>.isArray(values)) {
        list.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) </span>{
            returnObject[item] = values[index];
        });
    }
    <span class="hljs-keyword">return</span> returnObject;
}


<span class="hljs-comment">/**
 * A function to create flexibly-numbered lists of integers, handy for each and map loops. start, if omitted, defaults to 0; step defaults to 1. 
 * Returns a list of integers from start (inclusive) to stop (exclusive), incremented (or decremented) by step, exclusive. Note that ranges 
 * that stop before they start are considered to be zero-length instead of negative — if you'd like a negative range, use a negative step. 
 * @param {*} start 
 * @param {*} stop 
 * @param {*} step 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> resultArray = [],
        start = <span class="hljs-number">0</span>,
        step = <span class="hljs-number">1</span>,
        stop = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">arguments</span>.length) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            stop = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            start = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>];
            stop = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>];
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
            start = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>];
            stop = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>];
            step = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>];
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span>;
            <span class="hljs-keyword">break</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>abs function deals with the negative condition, to make sure the loop can run correctly.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; <span class="hljs-built_in">Math</span>.abs(i) &lt; <span class="hljs-built_in">Math</span>.abs(stop); i += step) {
        resultArray.push(i);
    }
    <span class="hljs-keyword">return</span> resultArray;
}
<span class="hljs-built_in">module</span>.exports = {
    first,
    initial,
    last,
    rest,
    compact,
    flatten,
    without,
    union,
    intersection,
    difference,
    zip,
    unzip,
    object,
    range
};</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
